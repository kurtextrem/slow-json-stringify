{"version":3,"file":"sjs.mjs","sources":["../src/_prepare.mjs","../src/_utils.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/_select.mjs","../src/sjs.mjs"],"sourcesContent":["const _stringifyCallback = (_, value) => {\n  if (!value.isSJS) return value;\n  return `${value.type}__sjs`;\n};\n\n/**\n * `_prepare` - aims to normalize the schema provided by the user.\n * It will convert the schema in both a parseable string and an object\n * useable for making the chunks needed for the serialization part.\n * @param {object} schema - user provided schema\n */\nconst _prepare = (schema) => {\n  const _preparedString = JSON.stringify(schema, _stringifyCallback);\n  const _preparedSchema = JSON.parse(_preparedString);\n\n  return {\n    _preparedString,\n    _preparedSchema,\n  };\n};\n\nexport { _prepare };\n","/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  let str = 'obj';\n\n  for (let i = 0; i < path.length; ++i) {\n    str = `(${str}||{}).${path[i]}`;\n  }\n\n  return eval(`(obj=>${str})`);\n};\n\nconst __find = (path) => {\n  let str = 'obj';\n\n  for (let i = 0; i < path.length; ++i) {\n    str += `?.['${path[i]}']`;\n  }\n\n  return eval(`(obj=>${str})`);\n};\n\nfunction _arraySerializer(serializer, array) {\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  const len = array.length - 1;\n  for (let i = 0; i < len; ++i) {\n    acc += `${serializer(array[i])},`;\n  }\n\n  // Prevent slice for removing unnecessary comma.\n  acc += serializer(array[len]);\n  console.log(acc);\n  return `[${acc}]`;\n}\n\n/**\n * `_makeArraySerializer` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n */\nconst _makeArraySerializer = (serializer) => {\n  if (serializer instanceof Function) return _arraySerializer.bind(null, serializer);\n  return JSON.stringify;\n};\n\nfunction _arrayNullSerializer(serializer, array) {\n  if (array === null) return 'null';\n  serializer(array);\n}\n\nconst _makeNullArraySerializer = (serializer) => {\n  const arraySerliazer = _makeArraySerializer(serializer);\n  return _arrayNullSerializer.bind(null, arraySerliazer);\n};\n\nconst TYPES = {\n  number: null,\n  string: null,\n  boolean: null,\n  array: _makeArraySerializer,\n  null: null,\n  nullArray: _makeNullArraySerializer,\n};\n\n/* #__PURE__ */\nfunction checkType(type) {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production' && TYPES[type] === undefined) {\n    throw new Error(\n      `Expected one of: \"number\", \"string\", \"boolean\", \"array\", \"null\", \"nullArray\". received \"${type}\" instead`,\n    );\n  }\n}\n\nconst fnUser = (value) => value;\n\n/**\n * @param type number|string|boolean|array|null|nullArray\n * @param serializer\n * @returns\n */\nconst attr = (type, serializer) => {\n  /* #__PURE__ */checkType(type);\n\n  return {\n    isSJS: true,\n    type,\n    serializer: TYPES[type]?.(serializer) || (serializer || fnUser),\n  };\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst _defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst _escapeCallback = (char) => '\\\\' + char;\nconst escape = (regex = _defaultRegex) => (str) => str.replace(regex, _escapeCallback);\n\nexport { __find, _find, escape, attr };\n","import { __find, _find } from \"./_utils.mjs\";\n\nconst _sjsRegex = /__sjs/;\n\nfunction _prepareQueue(originalSchema, queue, obj, acc = []) {\n  if (_sjsRegex.test(obj)) {\n    const usedAcc = Array.from(acc);\n    const find = __find(usedAcc);\n    const { serializer } = find(originalSchema);\n\n    queue.push({\n      serializer,\n      find,\n      name: acc[acc.length - 1],\n    });\n    return;\n  }\n\n  // Recursively going deeper.\n  // NOTE: While going deeper, the current prop is pushed into the accumulator\n  // to keep track of the position inside of the object.\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    _prepareQueue(originalSchema, queue, obj[key], [...acc, key]);\n  }\n}\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification serializers that are lost during preparation.\n */\nconst _makeQueue = (preparedSchema, originalSchema) => {\n  const queue = [];\n  _prepareQueue(originalSchema, queue, preparedSchema);\n  return queue;\n};\n\nexport { _makeQueue };\n","const _stringRegex = /string/;\n\nconst _replaceString = (type) => _stringRegex.test(type) ? '\"__par__\"' : \"__par__\";\n\nconst _isLastRegex = /^(\"}|})/;\n\nconst chunkRegex = /\"\\w+__sjs\"/gm;\n\n// 3 possibilities after arbitrary property:\n// - \", => non-last string property\n// - , => non-last non-string property\n// - \" => last string property\nconst _matchStartRe = /^(\\\"\\,|\\,|\\\")/;\n\n/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nconst _makeChunks = (str, queue) => {\n  chunkRegex.lastIndex = 0;\n  const chunks = str\n      // Matching prepared properties and replacing with target with or without\n      // double quotes.\n      // => Avoiding unnecessary concatenation of doublequotes during serialization.\n      .replace(chunkRegex, _replaceString)\n      .split(\"__par__\"),\n    result = [];\n\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i];\n\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = `(\"${queue[i]?.name}\":(\\\"?))$`;\n\n    // Check if current chunk is the last one inside a nested property\n    const isLast = _isLastRegex.test(chunks[i + 1] || \"\");\n\n    // If the chunk is the last one the `isUndef` case should match\n    // the preceding comma too.\n    const matchPropRe = new RegExp(isLast ? `(\\,?)${matchProp}` : matchProp);\n\n    result.push({\n      // notify that the chunk preceding the current one has not\n      // its corresponding property undefined.\n      // => This is a V8 optimization as it's way faster writing\n      // the value of a property than writing the entire property.\n      flag: false,\n      pure: chunk,\n      // Without initial part\n      prevUndef: chunk.replace(_matchStartRe, \"\"),\n      // Without property chars\n      isUndef: chunk.replace(matchPropRe, \"\"),\n      // Only remaining chars (can be zero chars)\n      bothUndef: chunk.replace(_matchStartRe, \"\").replace(matchPropRe, \"\"),\n    });\n  }\n\n  return result;\n};\n\nexport { _makeChunks };\n","/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst _select = (chunks) => (value, index) => {\n  const chunk = chunks[index];\n\n  if (value !== undefined) {\n    if (chunk.flag) {\n      return chunk.prevUndef + value;\n    }\n    return chunk.pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (chunk.flag) {\n    return chunk.bothUndef;\n  }\n  return chunk.isUndef;\n};\n\nexport { _select };\n","import { _prepare } from \"./_prepare.mjs\";\nimport { _makeQueue } from \"./_makeQueue.mjs\";\nimport { _makeChunks } from \"./_makeChunks.mjs\";\nimport { _select } from \"./_select.mjs\";\nimport { attr, escape } from \"./_utils.mjs\";\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const { _preparedString, _preparedSchema } = _prepare(schema);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(_preparedSchema, schema);\n  const chunks = _makeChunks(_preparedString, queue);\n  const selectChunk = _select(chunks);\n\n  const length = queue.length;\n\n  // Exposed function\n  return (obj) => {\n    let temp = \"\";\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { serializer, find } = queue[i];\n      const raw = find(obj);\n\n      temp += selectChunk(serializer(raw), i);\n\n      ++i;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport { sjs, attr, escape };\n"],"names":["_stringifyCallback","_","value","isSJS","type","_prepare","schema","_preparedString","JSON","stringify","_preparedSchema","parse","__find","path","str","i","length","eval","_arraySerializer","serializer","array","acc","len","console","log","_makeArraySerializer","Function","bind","_arrayNullSerializer","_makeNullArraySerializer","arraySerliazer","TYPES","number","string","boolean","null","nullArray","fnUser","attr","_defaultRegex","RegExp","_escapeCallback","char","escape","regex","replace","_sjsRegex","_prepareQueue","originalSchema","queue","obj","test","usedAcc","Array","from","find","push","name","keys","Object","key","_makeQueue","preparedSchema","_stringRegex","_replaceString","_isLastRegex","chunkRegex","_matchStartRe","_makeChunks","lastIndex","chunks","split","result","chunk","matchProp","_queue$i","isLast","matchPropRe","flag","pure","prevUndef","isUndef","bothUndef","_select","index","undefined","sjs","selectChunk","temp","raw"],"mappings":"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"}