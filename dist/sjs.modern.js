const _stringifyCallback=(e,r)=>r.isSJS?`${r.type}__sjs`:r,_prepare=e=>{const r=JSON.stringify(e,_stringifyCallback);return{_preparedString:r,_preparedSchema:JSON.parse(r)}},__find=path=>{let str="obj";for(let e=0;e<path.length;++e)str+=`?.['${path[e]}']`;return eval(`(obj=>${str})`)},_arraySerializer=(e,r)=>{let a="";const t=r.length-1;for(let n=0;n<t;++n)a+=`${e(r[n])},`;return a+=e(r[t]),console.log(a),`[${a}]`},_makeArraySerializer=e=>e instanceof Function?_arraySerializer.bind(null,e):JSON.stringify,_arrayNullSerializer=(e,r)=>{if(null===r)return"null";e(r)},_makeNullArraySerializer=e=>{const r=_makeArraySerializer(e);return _arrayNullSerializer.bind(null,r)},TYPES={number:null,string:null,boolean:null,array:_makeArraySerializer,null:null,nullArray:_makeNullArraySerializer},fnUser=e=>e,attr=(e,r)=>{var a;return{isSJS:!0,type:e,serializer:(null==(a=TYPES[e])?void 0:a.call(TYPES,r))||r||fnUser}},_defaultRegex=new RegExp('\\n|\\r|\\t|\\"|\\\\',"gm"),_escapeCallback=e=>"\\"+e,escape=(e=_defaultRegex)=>r=>r.replace(e,_escapeCallback),_sjsRegex=/__sjs/;function _prepareQueue(e,r,a,t=[]){if(_sjsRegex.test(a)){const a=[...t],n=__find(a),{serializer:l}=n(e);return void r.push({serializer:l,find:n,name:t[t.length-1]})}const n=Object.keys(a);for(let l=0;l<n.length;++l){const _=n[l];_prepareQueue(e,r,a[_],[...t,_])}}const _makeQueue=(e,r)=>{const a=[];return _prepareQueue(r,a,e),a},_stringRegex=/string/,_replaceString=e=>_stringRegex.test(e)?'"__par__"':"__par__",_isLastRegex=/^("}|})/,_matchStartRe=/^(\"\,|\,|\")/,_makeChunks=(e,r)=>{const a=e.replace(/"\w+__sjs"/gm,_replaceString).split("__par__"),t=[];for(let e=0;e<a.length;++e){const n=a[e],l=`("${(r[e]||{}).name}":("?))$`,_=_isLastRegex.test(a[e+1]||""),s=new RegExp(_?`(,?)${l}`:l);t.push({flag:!1,pure:n,prevUndef:n.replace(_matchStartRe,""),isUndef:n.replace(s,""),bothUndef:n.replace(_matchStartRe,"").replace(s,"")})}return t},_select=e=>(r,a)=>{const t=e[a];return void 0!==r?t.flag?t.prevUndef+r:t.pure+r:(e[a+1].flag=!0,t.flag?t.bothUndef:t.isUndef)},sjs=e=>{const{_preparedString:r,_preparedSchema:a}=_prepare(e),t=_makeQueue(a,e),n=_makeChunks(r,t),l=_select(n),_=t.length;return e=>{let r="",a=0;for(;a!==_;){const{serializer:n,find:_}=t[a],s=_(e);r+=l(n(s),a),++a}const{flag:s,pure:i,prevUndef:u}=n[n.length-1];return r+(s?u:i)}};export{attr,escape,sjs};
//# sourceMappingURL=sjs.modern.js.map
