{"version":3,"file":"sjs.modern.js","sources":["../src/_prepare.mjs","../src/_utils.mjs","../src/_makeQueue.mjs","../src/_makeChunks.mjs","../src/_select.mjs","../src/sjs.mjs"],"sourcesContent":["const _stringifyCallback = (_, value) => {\n  if (!value.isSJS) return value;\n  return `${value.type}__sjs`;\n};\n\n/**\n * `_prepare` - aims to normalize the schema provided by the user.\n * It will convert the schema in both a parseable string and an object\n * useable for making the chunks needed for the serialization part.\n * @param {object} schema - user provided schema\n */\nconst _prepare = (schema) => {\n  const _preparedString = JSON.stringify(schema, _stringifyCallback);\n  const _preparedSchema = JSON.parse(_preparedString);\n\n  return {\n    _preparedString,\n    _preparedSchema,\n  };\n};\n\nexport { _prepare };\n","/**\n * `_find` is a super fast deep property finder.\n * It dynamically build the function needed to reach the desired\n * property.\n *\n * e.g.\n * obj = {a: {b: {c: 1}}}\n * _find(['a','b','c']) => (obj) => (((obj || {}).a || {}).b || {}).c\n *\n * @param {array} path - path to reach object property.\n */\nconst _find = (path) => {\n  let str = 'obj';\n\n  for (let i = 0; i < path.length; ++i) {\n    str = `(${str}||{}).${path[i]}`;\n  }\n\n  return eval(`(obj=>${str})`);\n};\n\nconst __find = (path) => {\n  let str = 'obj';\n\n  for (let i = 0; i < path.length; ++i) {\n    str += `?.['${path[i]}']`;\n  }\n\n  return eval(`(obj=>${str})`);\n};\n\nconst _arraySerializer = (serializer, array) => {\n  // Stringifying more complex array using the provided sjs schema\n  let acc = '';\n  const len = array.length - 1;\n  for (let i = 0; i < len; ++i) {\n    acc += `${serializer(array[i])},`;\n  }\n\n  // Prevent slice for removing unnecessary comma.\n  acc += serializer(array[len]);\n  console.log(acc);\n  return `[${acc}]`;\n}\n\n/**\n * `_makeArraySerializer` is simply a wrapper of another `sjs` schema\n * used for the serialization of arrais.\n */\nconst _makeArraySerializer = (serializer) => {\n  if (serializer instanceof Function) return _arraySerializer.bind(null, serializer);\n  return JSON.stringify;\n};\n\nconst _arrayNullSerializer = (serializer, array) => {\n  if (array === null) return 'null';\n  serializer(array);\n}\n\nconst _makeNullArraySerializer = (serializer) => {\n  const arraySerliazer = _makeArraySerializer(serializer);\n  return _arrayNullSerializer.bind(null, arraySerliazer);\n};\n\nconst TYPES = {\n  number: null,\n  string: null,\n  boolean: null,\n  array: _makeArraySerializer,\n  null: null,\n  nullArray: _makeNullArraySerializer,\n};\n\n/* #__PURE__ */\nfunction checkType(type) {\n  if (typeof process !== 'undefined' && process.env.NODE_ENV !== 'production' && TYPES[type] === undefined) {\n    throw new Error(\n      `Expected one of: \"number\", \"string\", \"boolean\", \"array\", \"null\", \"nullArray\". received \"${type}\" instead`,\n    );\n  }\n}\n\nconst fnUser = (value) => value;\n\n/**\n * @param type number|string|boolean|array|null\n * @param serializer\n * @returns\n */\nconst attr = (type, serializer) => {\n  /* #__PURE__ */checkType(type);\n\n  return {\n    isSJS: true,\n    type,\n    serializer: TYPES[type]?.(serializer) || (serializer || fnUser),\n  };\n};\n\n// Little utility for escaping convenience.\n// => if no regex is provided, a default one will be used.\nconst _defaultRegex = new RegExp('\\\\n|\\\\r|\\\\t|\\\\\"|\\\\\\\\', 'gm');\nconst _escapeCallback = (char) => '\\\\' + char;\nconst escape = (regex = _defaultRegex) => (str) => str.replace(regex, _escapeCallback);\n\nexport { __find, _find, escape, attr };\n","import { __find, _find } from \"./_utils.mjs\";\n\nconst _sjsRegex = /__sjs/;\n\nfunction _prepareQueue(originalSchema, queue, obj, acc = []) {\n  if (_sjsRegex.test(obj)) {\n    const usedAcc = [...acc];\n    const find = __find(usedAcc);\n    const { serializer } = find(originalSchema);\n\n    queue.push({\n      serializer,\n      find,\n      name: acc[acc.length - 1],\n    });\n    return;\n  }\n\n  // Recursively going deeper.\n  // NOTE: While going deeper, the current prop is pushed into the accumulator\n  // to keep track of the position inside of the object.\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; ++i) {\n    const key = keys[i];\n    _prepareQueue(originalSchema, queue, obj[key], [...acc, key]);\n  }\n}\n\n/**\n * @param {object} preparedSchema - schema already validated\n * with modified prop values to avoid clashes.\n * @param {object} originalSchema - User provided schema\n * => contains array stringification serializers that are lost during preparation.\n */\nconst _makeQueue = (preparedSchema, originalSchema) => {\n  const queue = [];\n  _prepareQueue(originalSchema, queue, preparedSchema);\n  return queue;\n};\n\nexport { _makeQueue };\n","const _stringRegex = /string/;\n\nconst _replaceString = (type) =>\n  _stringRegex.test(type) ? '\"__par__\"' : \"__par__\";\n\nconst _isLastRegex = /^(\"}|})/;\n\n// 3 possibilities after arbitrary property:\n// - \", => non-last string property\n// - , => non-last non-string property\n// - \" => last string property\nconst _matchStartRe = /^(\\\"\\,|\\,|\\\")/;\n\n/**\n * @param {string} str - prepared string already validated.\n * @param {array} queue - queue containing the property name to match\n * (used for building dynamic regex) needed for the preparation of\n * chunks used in different scenarios.\n */\nconst _makeChunks = (str, queue) => {\n  const chunks = str\n      // Matching prepared properties and replacing with target with or without\n      // double quotes.\n      // => Avoiding unnecessary concatenation of doublequotes during serialization.\n      .replace(/\"\\w+__sjs\"/gm, _replaceString)\n      .split(\"__par__\"),\n    result = [];\n\n  for (let i = 0; i < chunks.length; ++i) {\n    const chunk = chunks[i];\n\n    // Using dynamic regex to ensure that only the correct property\n    // at the end of the string it's actually selected.\n    // => e.g. ,\"a\":{\"a\": => ,\"a\":{\n    const matchProp = `(\"${(queue[i] || {}).name}\":(\\\"?))$`;\n\n    // Check if current chunk is the last one inside a nested property\n    const isLast = _isLastRegex.test(chunks[i + 1] || \"\");\n\n    // If the chunk is the last one the `isUndef` case should match\n    // the preceding comma too.\n    const matchPropRe = new RegExp(isLast ? `(\\,?)${matchProp}` : matchProp);\n\n    result.push({\n      // notify that the chunk preceding the current one has not\n      // its corresponding property undefined.\n      // => This is a V8 optimization as it's way faster writing\n      // the value of a property than writing the entire property.\n      flag: false,\n      pure: chunk,\n      // Without initial part\n      prevUndef: chunk.replace(_matchStartRe, \"\"),\n      // Without property chars\n      isUndef: chunk.replace(matchPropRe, \"\"),\n      // Only remaining chars (can be zero chars)\n      bothUndef: chunk.replace(_matchStartRe, \"\").replace(matchPropRe, \"\"),\n    });\n  }\n\n  return result;\n};\n\nexport { _makeChunks };\n","/**\n * `select` function takes all the possible chunks from the\n * current index and set the more appropriate one in relation\n * to the current `value` and the `flag` state.\n *\n * => This approach avoids the use of Regex during serialization.\n *\n * @param {any} value - value to serialize.\n * @param {number} index - position inside the queue.\n */\nconst _select = (chunks) => (value, index) => {\n  const chunk = chunks[index];\n\n  if (value !== undefined) {\n    if (chunk.flag) {\n      return chunk.prevUndef + value;\n    }\n    return chunk.pure + value;\n  }\n\n  // If the current value is undefined set a flag on the next\n  // chunk stating that the previous prop is undefined.\n  chunks[index + 1].flag = true;\n\n  if (chunk.flag) {\n    return chunk.bothUndef;\n  }\n  return chunk.isUndef;\n};\n\nexport { _select };\n","import { _prepare } from \"./_prepare.mjs\";\nimport { _makeQueue } from \"./_makeQueue.mjs\";\nimport { _makeChunks } from \"./_makeChunks.mjs\";\nimport { _select } from \"./_select.mjs\";\nimport { attr, escape } from \"./_utils.mjs\";\n\n// Doing a lot of preparation work before returning the final function responsible for\n// the stringification.\nconst sjs = (schema) => {\n  const { _preparedString, _preparedSchema } = _prepare(schema);\n\n  // Providing preparedSchema for univocal correspondence between created queue and chunks.\n  // Provided original schema to keep track of the original properties that gets destroied\n  // during schema preparation => e.g. array stringification method.\n  const queue = _makeQueue(_preparedSchema, schema);\n  const chunks = _makeChunks(_preparedString, queue);\n  const selectChunk = _select(chunks);\n\n  const length = queue.length;\n\n  // Exposed function\n  return (obj) => {\n    let temp = \"\";\n\n    // Ditching old implementation for a **MUCH** faster while\n    let i = 0;\n    while (true) {\n      if (i === length) break;\n      const { serializer, find } = queue[i];\n      const raw = find(obj);\n\n      temp += selectChunk(serializer(raw), i);\n\n      ++i;\n    }\n\n    const { flag, pure, prevUndef } = chunks[chunks.length - 1];\n\n    return temp + (flag ? prevUndef : pure);\n  };\n};\n\nexport { sjs, attr, escape };\n"],"names":["_stringifyCallback","_","value","isSJS","type","_prepare","schema","_preparedString","JSON","stringify","_preparedSchema","parse","__find","path","str","i","length","eval","_arraySerializer","serializer","array","acc","len","console","log","_makeArraySerializer","Function","bind","_arrayNullSerializer","_makeNullArraySerializer","arraySerliazer","TYPES","number","string","boolean","null","nullArray","fnUser","attr","_defaultRegex","RegExp","_escapeCallback","char","escape","regex","replace","_sjsRegex","_prepareQueue","originalSchema","queue","obj","test","usedAcc","find","push","name","keys","Object","key","_makeQueue","preparedSchema","_stringRegex","_replaceString","_isLastRegex","_matchStartRe","_makeChunks","chunks","split","result","chunk","matchProp","isLast","matchPropRe","flag","pure","prevUndef","isUndef","bothUndef","_select","index","undefined","sjs","selectChunk","temp","raw"],"mappings":"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"}